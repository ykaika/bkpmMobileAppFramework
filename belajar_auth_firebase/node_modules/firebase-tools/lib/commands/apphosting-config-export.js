"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.command = void 0;
const command_1 = require("../command");
const projectUtils_1 = require("../projectUtils");
const requireAuth_1 = require("../requireAuth");
const secretManager = require("../gcp/secretManager");
const requirePermissions_1 = require("../requirePermissions");
const config_1 = require("../apphosting/config");
const error_1 = require("../error");
const detectProjectRoot_1 = require("../detectProjectRoot");
exports.command = new command_1.Command("apphosting:config:export")
    .description("Export App Hosting configurations such as secrets into an apphosting.local.yaml file")
    .option("-s, --secrets <apphosting.yaml or apphosting.<environment>.yaml file to export secrets from>", "This command combines the base apphosting.yaml with the specified environment-specific file (e.g., apphosting.staging.yaml). If keys conflict, the environment-specific file takes precedence.")
    .before(requireAuth_1.requireAuth)
    .before(secretManager.ensureApi)
    .before(requirePermissions_1.requirePermissions, ["secretmanager.versions.access"])
    .action(async (options) => {
    var _a;
    const projectId = (0, projectUtils_1.needProjectId)(options);
    const environmentConfigFile = options.secrets;
    const cwd = process.cwd();
    const backendRoot = (0, config_1.discoverBackendRoot)(cwd);
    if (!backendRoot) {
        throw new error_1.FirebaseError("Missing apphosting.yaml: This command requires an apphosting.yaml configuration file. Please run 'firebase init apphosting' and try again.");
    }
    const projectRoot = (_a = (0, detectProjectRoot_1.detectProjectRoot)({})) !== null && _a !== void 0 ? _a : backendRoot;
    await (0, config_1.exportConfig)(cwd, projectRoot, backendRoot, projectId, environmentConfigFile);
});
